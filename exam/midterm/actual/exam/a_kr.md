# Problem a: 힙 (Heap)

(21점)

힙(Heap)은 노드에 키를 저장하는 이진 트리(binary tree)로서 다음 두 가지 속성을 만족해야 합니다:

- 힙 순서(Heap-Order): 루트를 제외한 모든 내부 노드 `v`에 대해 `key(v) >= key(parent(v))`를 만족해야 합니다.
- 완전 이진 트리(Complete Binary Tree): 힙의 높이를 `h`라고 할 때,
    - 깊이 `i = 0, ..., h-1`에는 각각 `2^i`개의 노드가 존재합니다.
    - 깊이 `h-1`에서는 내부 노드가 외부 노드보다 왼쪽에 위치해야 합니다.

`HeapSkeleton` 클래스의 기본 구조가 제공되어 있으니 참고하여 문제를 해결하세요.

## Problem a1: Up and Down

(중간 난이도, 8점)

`HeapBase` 클래스를 완성하세요. 현재 `_upheap`과 `_downheap` 메서드는 구현이 완성되지 않았습니다. 이 메서드들을 구현하여 `HeapBase` 클래스를 완성하십시오.

- `_upheap(self, j: int)`: 인덱스 `j`에 있는 노드를 힙 순서 속성이 만족될 때까지 위로 올립니다. 반환값(return value)은 없습니다.

- `_downheap(self, j: int)`: 인덱스 `j`에 있는 노드를 힙 순서 속성이 만족될 때까지 아래로 내립니다. 반환값(return value)은 없습니다.

## Problem a2: Heap Implementation

(중간 난이도, 8점)

다음 메서드들을 `Heap` 클래스에 구현하세요:

- `add(self, key: int)`: 새로운 키를 힙에 삽입합니다. 반환값(return value)은 없습니다.

    참고: 새 키는 힙의 끝(배열에서 다음 사용 가능한 위치)에 추가된 뒤, 힙 순서 속성을 유지하기 위해 위로 이동되어야 합니다.

- `remove_min(self) -> int`: 힙에서 최소 키를 제거하고 반환합니다. 제거 후에도 힙 순서 속성이 유지되도록 해야 합니다.

    참고 1: 최소 키는 힙의 루트입니다.  

    참고 2: 힙이 비어 있을 경우 예외를 발생시켜야 합니다. (`raise IndexError()` 등 사용)

## Problem a3: Heap Sort

(쉬움, 5점)

다음 함수를 구현하세요:

- `heap_sort(arr: list[int]) -> list[int]`: 이 함수는 정수 리스트를 입력으로 받아, 오름차순으로 정렬한 새 리스트를 반환해야 합니다. 이 함수를 구현할 때는 반드시 앞서 만든 `Heap` 클래스를 사용해야 합니다.

    참고 1: 내장 정렬 함수나 기타 라이브러리는 사용할 수 없습니다.  

    참고 2: 원본 리스트는 변경되지 않아야 하며, 정렬된 새로운 리스트를 반환해야 합니다.
