# Problem b: Binary Trees

(총 34점)

이 문제에서는 각 노드가 고유한 `key`를 갖는 이진 트리에 대한 여러 가지 함수를 구현해야 합니다. 기본 `BinaryTree` 클래스와 노드를 나타내는 `_Node` 클래스가 제공됩니다. 각 노드는 `key`, `parent` (부모 노드), `left` (왼쪽 자식 노드), `right` (오른쪽 자식 노드) 정보를 저장합니다.

이 문제는 *완전 이진 트리*를 가정합니다. 즉, 마지막 레벨을 제외한 모든 레벨은 꽉 차 있으며, 마지막 레벨은 왼쪽에서 오른쪽 순서로 채워집니다.

## Problem b1: Preorder Traversal

(쉬움, 5점)

다음 함수를 구현하세요:

- `preorder(tree: BinaryTree) -> list[int]`: 이 함수는 이진 트리 `tree`를 입력받아, 전위 순회 방식으로 노드를 방문하며 각 노드의 `key`를 리스트로 반환합니다.

    전위 순회는 다음 순서로 트리를 순회하는 방법입니다: 부모, 왼쪽 자식, 오른쪽 자식

    ```plaintext
            1
          /    \
         9      8
        / \    / 
       6   2  3
    ```

    위 예시 트리에서 전위 순위 수행 시 다음과 같은 python list를  출력하여야 합니다: `[1, 9, 6, 2, 8, 3]`

    참고: 재귀 방식으로 구현이 가능합니다.

    참고2: 트리가 비어 있으면 빈 리스트를 반환하세요.

    참고3: 트리의 루트 노드는 `tree.root()`로 접근할 수 있습니다.

## Problem b2: Postorder Traversal

(쉬움, 5점)

다음 함수를 구현하세요:

- `postorder(tree: BinaryTree) -> list[int]`: 이 함수는 이진 트리 `tree`를 입력받아, 후위 순회 방식으로 노드를 방문하며 각 노드의 `key`를 리스트로 반환합니다.

    후위 순회는 다음 순서로 트리를 순회하는 방법입니다: 왼쪽 자식, 오른쪽 자식, 부모

    ```plaintext
            1
          /    \
         9      8
        / \    / 
       6   2  3
    ```

    위 예시 트리에서 전위 순위 수행 시 다음과 같은 python list를  출력하여야 합니다: `[6, 2, 9, 3, 8, 1]`

## Problem b3: Depth of a Node

(중간 난이도, 8점)

다음 함수를 구현하세요:

- `depth(tree: BinaryTree, key: int) -> int`: 이 함수는 트리 `tree`와 정수 `key`를 받아 해당 `key`를 가진 노드의 깊이를 반환합니다. 만약 해당 노드가 트리에 없다면 `-1`을 반환합니다.

    ```plaintext
            1
          /    \
         9      8
        / \    / 
       6   2  3
    ```

    위 트리 예시에서 `key`가 `1`인 노드(루트)의 깊이: `0`, `key`가 `9`인 노드의 깊이: `1`, `key`가 `3`인 노드의 깊이: `2`.

## Problem b4: Find Uncle

(중간 난이도, 8점)

다음 함수를 구현하세요:

- `uncle(tree: BinaryTree, key: int) -> int`: 트리 `tree`와 정수 `key`를 받아 해당 노드의 "삼촌" 노드의 `key`를 반환합니다. 삼촌 노드가 없거나 해당 노드가 트리에 없으면 `-1`을 반환하세요.

    삼촌 노드란 부모 노드의 형제 노드를 뜻합니다. 부모 노드가 형제가 없거나, 입력 노드가 루트일 경우 삼촌 노드는 없습니다. 이 경우 `-1`을 반환하세요.

    ```plaintext
            1
          /    \
         9      8
        / \    / 
       6   2  3
    ```

    위 트리 예시에서 `key`가 `6`인 노드의 삼촌: `8`, `key`가 `3`인 노드의 삼촌: `9`, `key`가 `1`인 노드(루트): 삼촌 노드 없음, `-1`, `key`가 `9`인 노드: 부모 노드(`1`)가 형제 노드가 없으므로, `-1`.

## Problem b5: Maximum Path Sum

(중간 난이도, 8점)

다음 함수를 구현하세요:

- `max_path_sum(tree: BinaryTree) -> int`: 이 함수는 트리 `tree`를 입력받아, 루트에서 리프 노드까지 갈 수 있는 경로 중 `key`의 합이 가장 큰 값을 반환합니다.

    ```plaintext
            1
          /    \
         9      8
        / \    / 
       6   2  3
    ```

    위 트리 예시에서 최대 경로: `1 -> 9 -> 6`, 경로 합: `1 + 9 + 6 = 16`

    참고: 트리가 비어 있으면 `0`을 반환하세요.  

    참고2: 루트만 있을 경우, 그 `key`가 곧 최대 경로 합입니다.
